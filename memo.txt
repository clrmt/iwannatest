확실하지 않음. 제보 환영.



=== 키보드 이벤트 ===
상하좌우 키는 누를 때 True, 뗄 때 False의 이진 데이터로 표기해도 좋다.
만약 한 프레임이 지나기도 전에 방향키가 눌린 다음 떼졌다면 이동하지 않는다.
즉, 임의의 시간에 0.01초동안 방향키를 눌렀다가 떼면 이동이 될 때도 있고 안 될 때도 있다.

하지만 shootDown, shiftDown, shiftUp, RestartDown 키는 처리 방식이 다르다.(~Down은 키가 눌리는 신호, ~Up은 뗀 신호이다.)
눌렸을 때 각각 True로 바뀌고, 키를 취소했다고 해도 False로 바뀌지 않는다.
다음 프레임에서 이것을 모두 처리하면서 False로 바꾼다.
즉 아무리 짧은 시간 동안 키를 눌러도 이것은 항상 처리된다.



== 프레임 ==
프레임은 게임이 처리되는 단위로, 이 게임에서는 초당 50프레임, 0.02초마다 1프레임이다.
프로그램을 정확히 0.02초마다 한 번씩 실행되게 구현하기는 생각보다 어렵다. 오차가 계속 발생함.
게임엔진의 힘을 빌려도 좋지만, 어떤 게임엔진을 사용하면 물리법칙을 GameMaker와 동일하게 구현하기 어려울 수도 있다.



=== 게임의 물리법칙 ===

== 좌우이동 ==
프레임 처리동안 오른쪽 키가 눌린 경우 1f마다 오른쪽으로 3px 이동, 왼쪽 키가 눌리면 왼쪽으로 3px 이동한다. 둘 다 눌리면 오른쪽으로 간다.



== 점프 ==
1프레임 내에서 처리 순서는 shiftDown -> shiftUp 순이다.
두 이벤트는 개별적으로 처리된다.

shiftDown 처리시 y속력을 어떤 음숫값으로 고정한다. 이것은 쉽게 말해 점프이다.
착지상태에서의 점프시 y속력은 -8.5, 공중에서는 -7.0가 된다.
점프 직후에는 y속력이 음수였다가 1프레임마다 중력(가속력) 0.4가 계속 더해져서 양수가 된다.
y속력이 양수라는 뜻은 아래로 떨어진다는 뜻이다.
y속력은 최대치가 9.0이지만 중력 0.4를 더하는 연산이 나중이므로 실제로는 9.4까지 올라간다.

shiftUp이 발동되면 y속력이 음수일 때 그 값에 *0.45를 곱한다.
그렇게 되면 속력이 음수인 구간이 단축되어 더 빠르게 낙하할 수 있다.



= x프레임 점프 =
만약 하나의 프레임 동안에 shiftDown, shiftUp이 모두 발생했다면
(0f 점프라는 표현이 더 정확하지만) 이것을 1f 점프로 정의한다.
같은 이유로 shiftDown이 발생하고 3f 뒤에 shiftUp이 발생했다면, 이것은 4f 점프이다.
1f 점프, 즉 한 프레임에서 shiftDown, shiftUp을 모두 처리할 때는 기존과 별 특이사항이 없다.
shiftDown에 의해 y속력이 음수가 되고나서 바로 shiftUp에 의한 *0.45가 적용되어 매우 낮은 점프가 된다.



= 점프키의 중첩 =
모든 프로그램의 키보드 입력은 기본적으로, 키가 눌려있는 동안에 반복적으로 발동이 된다.
텍스트 에디터를 켜고 'A'키를 계속 누르고 있으면 키가 반복하여 입력되는데
그 때마다 각각 keyDown 메시지를 처리한 것이다.
이때는 실제로 어플리케이션에 keyDown - keyDown - keyDown - ...  - keyDown - keyUp의 이벤트가 발생한다.
만약 게임 프로그램이 별다른 조치를 하지 않는다면,
'shoot' 키를 누르고 있는 동안 Kid는 총알을 빠르게 연사할 것이다.
이를 막기 위해서 특정 키는 keyUp 이벤트가 발생하기 전까지 최초 1번만 keyDown 이벤트를 처리한다.

이제 키보드를 떠나서 매크로 스크립트를 이용해 keyDown, keyUp을 임의로 발생시키는 경우를 생각해보자.
keyDown을 반복적으로 입력하게끔 스크립트를 짜더라도, 위에 적힌 원리에 따라 최초 1회의 keyDown만 효력이 있다.
AutoHotKey 등의 프로그램을 이용해 다수의 키를 shift 키로 바인딩한 뒤 차례대로 누른 상태를 유지하면 처음의 점프만 발동된다.
이와 달리 keyUp 이벤트는 어느때나 적용이 가능하다.
이제 눌려있는 다수의 shift 키를 순서대로 떼면, 각 프레임마다 keyUp 이벤트가 처리된다.
만약 Kid가 점프로 상승중일 때 이것을 시도하면 *0.45가 반복 처리되어 y속력이 음수인 구간을 더욱 단축시킬 수 있다.
이것을 cactus (strategy)라 부른다.

한 프레임 안에서 keyDown과 keyUp의 순서대로 발생한 것과, keyUp, keyDown의 순서대로 발생한 경우
내부적으로는 순서에 상관없이 동일한 기능을 한다.
하지만 이후에 keyDown이 먼저 들어왔을 때 전자는 처리할 수 있지만, 후자는 처리가 안 된다.



== 충돌 ==
Kid의 충돌 영역은 가로 11px, 세로 21px, 기본 블럭은 32px×32px, 가시와 사과 등의 killer들은 이미지 픽셀이 존재하는 곳이 모두 충돌 영역이다.

= hfpi, vfpi =
Kid의 x, y위치의 소수 부분이 0.499999나 0.500001이 아닌 정확히 0.5가 될 때 충돌 판정이 이상해진다.
x방향의 버그는 hfpi, y방향의 버그는 vfpi라 한다.
간단히 설명하기 위해 모든 것이 1픽셀 오브젝트라고 가정하고 블럭이 y=5에 있고 가시가 y=4에 있다면,
가시가 더 위에 있으므로 Kid가 y=0에서부터 아래로 내려왔을 때 가시에 닿고 죽어야 정상이다.
GameMaker의 엔진은 플랫폼과 충돌했을 때 -1칸씩 이동해보면서 충돌이 아닌 지점을 찾는다.
Kid가 떨어지면서 순간 y가 4.5가 되었다면 블럭과 충돌하였다고 판단하고 Kid를 위로 한 칸 올리고 3.5로 만든다.
만약 3.5에도 블럭이 있었다면 2.5가 되었겠지만 3.5는 블럭과 충돌하는 지점이 아니므로
y=3.5에서 착지 판정이 나온다. 착지 판정을 받았다는 말은 첫 점프를 할 수 있다는 말과 동일하다.
그리고 가시는 y > 3.5에서 충돌 판정이 일어나므로 y = 3.5에 있는 Kid는 죽지 않고 바로 점프를 뛸 수 있다.
여기서 1프레임이라도 지체되면 중력 0.4에 의해 아래로 조금 내려가므로 죽게 된다.

= 블럭에 착지 =
JTool을 이용해 프레임을 느리게 해놓고 점프를 하면 Kid가 착지할 때 1~3번 착지 모션이 일어난다는 것을 알 수 있다.
GameMaker의 물리엔진상 블럭에 착지해 충돌이 일어났다면, 1칸씩 뒤로 이동하면서 충돌이 안 일어나게 조정한다.
모든 것이 1픽셀 오브젝트라고 가정하고 블럭이 y=5에 있다면 4.5 <= y <= 5.5가 블럭의 충돌 영역이다.
Kid가 y=0에서 시작해 프레임이 진행하면서 y=0.4, y=1.2, ..., 그리고 어찌됐건 y=4.6이 되었다면
블럭과 충돌이 일어났으므로 Kid는 y=3.6으로 조정된 후 착지 판정이 나온다.
다시 중력에 의해 0.4의 속력이 붙고 공중에 있는 판정이 나온다. 이때 키드의 위치는 y=4.0
다음 속력은 0.8이 되고 다음 위치는 y=4.8에서 블럭과 충돌하므로 다시 착지 판정이 나온다.
중력에 의해 속력 0.4가 붙어 하강하고, y=5.2에서 다시 착지 판정이 나온다.
이렇게 하면 총 3번 착지하게 된다.
이 원리상 y의 소수 부분이 .5~.7이면 3번 착지하게 되고, .7~.1이면 2번 착지하고 .1~.5이면 1번 착지하고
모든 착지가 끝나면 y의 소수 부분은 항상 0.1~0.5 사이가 된다. 이는 중력이 0.4인 것과 연관이 있다.
착지를 3번 하는 경우 첫 번째 착지 지점은 블럭으로부터 약 1px정도 위로 떨어져 있다.
이때는 착지된 상태이므로 점프가 가능한데, 이렇게 살짝 높은 위치에서 점프하는 것을 
bunny hop(bh)이라 하며, 살짝 높은 상태에서 (어떻게든)하강하는 것을 bunny fall(bf)이라 한다.



= 충돌의 구현 =
충돌 검사를 할 때는 화면에 보이지 않는 내부적인 canvas(bitmap)를 선언하고 화면과 동일하게 블럭 또는 킬러 오브젝트를 그린 뒤
키드가 있는 픽셀에 블럭이나 킬러가 있는지 검사하면 된다.
이렇게 하면 GPU를 활용하게 되므로 빠르게 충돌 검사를 할 수 있다.
픽셀을 단순 배열로 관리한다면 엄청난 성능 저하가 일어날 것이다.



= X, Y 이동이 혼합된 경우 블럭의 충돌 판정 =
생각보다 복잡하고 이상하다. 내가 알아낸 법칙이 맞는지도 모르겠다.
만약 X, Y속력에 의해 계산된 다음 위치에 충돌이 없다면 그곳으로 이동한다.
만약 그 지점에 충돌이 있다면, X방향으로 충돌이 있는지의 여부를 검토한다.
만약 충돌이 없다면 Y방향으로 이동한 후 X방향으로 이동한다.
충돌이 있다면 X방향으로 이동한 후 Y방향으로 이동한다.
이동할 때는, 만약 그 지점에 충돌이 있다면 1px씩 뒤로 이동하면서 충돌이 없는 지점을 찾는다.

-X-
-XX
O--
오른쪽 방향과 위 방향이 양의 방향이고 키드가 O, 블럭이 X, 빈 공간이 -이다.
오른쪽 방향키와 점프를 같이 눌러서 키드의 속력이 (X, Y) = (2, 2)가 되었다면
다음 프레임에서는 맨 오른쪽 위로 이동된다.

-XX
-XX
O--
위와 같은 상황에서 키드의 속력이 (X, Y) = (2, 2)이라면 위로 두 칸 이동된다.

-XX
-XX
O-X
위와 같은 상황에서 키드의 속력이 (X, Y) = (2, 2)이라면 한 칸 오른쪽으로 이동된다.

= 킬러의 충돌 판정 =
킬러에 의한 충돌검사는 Kid가 마지막에 이동되는 지점에서 1회만 실시하면 된다.